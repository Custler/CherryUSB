Универсальное руководство по портированию чипов
=========================

В этом разделе описываются общие шаги и предостережения при портировании стека протоколов CherryUSB для всех чипов с USB IP. Прежде чем продолжить, вам необходимо **подготовить базовый проект, который может выводить helloworld**, а также реализовать функции `printf`, `malloc`, `free`. Если это хост, вам нужно **подготовить проект с ОС, который также может выводить helloworld**.

Основные моменты портирования USB Device
-----------------------

- Скопируйте исходный код CherryUSB в каталог проекта и при необходимости добавьте пути к исходным файлам и заголовочным файлам. Файлы `usbd_core.c` и `usb_dc_xxx.c` должны быть добавлены обязательно. Файл `usb_dc_xxx.c` является частью драйвера USB IP DCD для вашего чипа. Если вы не знаете, к какому USB IP относится ваш чип, смотрите readme в каталоге **port** для разных USB IP. Если для вашего USB IP нет поддержки, вам придется реализовать её самостоятельно.
- Добавьте три опции компиляции cflag: `USBD_IRQHandler=xxxx`, `USB_NUM_BIDIR_ENDPOINTS=x` и `USB_BASE=0xxxxx`. Если они не добавлены, используйте конфигурацию по умолчанию из `usb_dc_xxx.c`.
- Скопируйте файл `cherryusb_config_template.h` в каталог своего проекта, переименуйте его в `usb_config.h` и добавьте соответствующие пути к заголовочным файлам.
- Реализуйте функцию `usb_dc_low_level_init` (эта функция в основном отвечает за инициализацию USB часов, пинов, прерываний). Эту функцию можно поместить в любой c файл, который участвует в компиляции. Как инициализировать часы USB, пины, прерывания и т. д., смотрите в исходном коде от производителя чипа.
- Регистрация дескрипторов, классов, интерфейсов, прерываний конечных точек. Если не знаете как, смотрите шаблон в демо.
- Вызовите `usbd_initialize` для инициализации аппаратных средств USB.
- Скомпилируйте и используйте. Как использовать различные классы, смотрите шаблон в демо.

.. note:: Основные моменты портирования device на самом деле всего три: реализация `usb_dc_low_level_init`; изменение `USBD_IRQHandler=xxxx`, `USB_BASE=0xxxxx`, `USB_NUM_BIDIR_ENDPOINTS=x`; изменение содержимого `usb_config.h`. Упомянутые ранее три макроса также можно добавить в `usb_config.h`.

Основные моменты портирования USB Host
-----------------------

- Скопируйте исходный код CherryUSB в каталог проекта и при необходимости добавьте пути к исходным файлам и заголовочным файлам, в том числе `usbh_core.c`, `usb_hc_xxx.c` и исходные файлы из каталога **osal** (в зависимости от используемой ОС). Файл `usb_hc_xxx.c` является частью драйвера USB IP DCD для вашего чипа. Если вы не знаете, к какому USB IP относится ваш чип, смотрите readme в каталоге **port** для разных USB IP. Если для вашего USB IP нет поддержки, вам придется реализовать её самостоятельно.
- Добавьте опции компиляции cflag: `USBH_IRQHandler=xxxx` и `USB_BASE=0xxxxx`. Если они не добавлены, используйте конфигурацию по умолчанию из `usb_hc_xxx.c`.
- Скопируйте файл `cherryusb_config_template.h` в каталог своего проекта, переименуйте его в `usb_config.h` и добавьте соответствующие пути к заголовочным файлам.
- Реализуйте функцию `usb_hc_low_level_init` (эта функция в основном отвечает за инициализацию USB часов, пинов, прерываний). Эту функцию можно поместить в любой c файл, который участвует в компиляции. Как инициализировать часы USB, пины, прерывания и т. д., смотрите в исходном коде от производителя чипа.
- Вызовите `usbh_initialize` для инициализации аппаратных средств USB.
- Если вы используете GCC, вам нужно добавить следующий код в ваш скрипт линковки (ld):

.. code-block:: C

        /* информация о секции для класса usbh */
        . = ALIGN(4);
        __usbh_class_info_start__ = .;
        KEEP(*(.usbh_class_info))
        __usbh_class_info_end__ = .;

- Если вы используете Segger Embedded Studio, вам нужно добавить следующий код в ваш скрипт линковки (icf):

.. code-block:: C

        define block cherryusb_usbh_class_info { section .usbh_class_info };

        define exported symbol __usbh_class_info_start__  = start of block cherryusb_usbh_class_info;
        define exported symbol __usbh_class_info_end__  = end of block cherryusb_usbh_class_info + 1;

        place in AXI_SRAM                         { block cherryusb_usbh_class_info };
        keep { section .usbh_class_info};

- Скомпилируйте и используйте. Как использовать различные классы, смотрите файл `usb_host.c` в демо.

.. caution:: Если ведомый и главный IP используют одно и то же прерывание, установите `USBD_IRQHandler=USBD_IRQHandler` и `USBH_IRQHandler=USBH_IRQHandler`, затем пусть реальная функция прерывания вызывает эти две функции в зависимости от режима ведущего или ведомого.

Внимание при использовании чипов с кэшем
-------------------------------

Протокольный стек и порт не будут очищать или инвалидировать кэш для области RAM, так что необходимо использовать RAM без кэша. Макрос `USB_NOCACHE_RAM_SECTION` указывает на то, что переменная должна быть размещена в RAM без кэша,
поэтому пользователь должен добавить секцию RAM без кэша в соответствующий скрипт линковки. По умолчанию `USB_NOCACHE_RAM_SECTION` определён как `__attribute__((section(".noncacheable")))`.

GCC:

.. code-block:: C

        // Размещается в области RAM без кэша
        .no_cache_ram_region : AT (__no_cache_ram_addr)
        {
                . = ALIGN(4);
                *(.noncacheable)
                . = ALIGN(4);
        } > no_cache_ram

SCT:

.. code-block:: C

    LR_IROM1 0x08000000 0x00200000  {    ; load region size_region
    ER_IROM1 0x08000000 0x00200000  {  ; load address = execution address
    *.o (RESET, +First)
    *(InRoot$$Sections)
    .ANY (+RO)
    .ANY (+XO)
    }
    RW_IRAM2 0x24000000 0x00070000  {  ; RW data
    .ANY (+RW +ZI)
    }
    USB_NOCACHERAM 0x24070000 0x00010000  {  ; RW data
    *(.noncacheable)
    }
    }

ICF:

.. code-block:: C

        define region NONCACHEABLE_RAM = [from 0x1140000 size 256K];
        place in NONCACHEABLE_RAM                   { section .noncacheable, section .noncacheable.init, section .noncacheable.bss };  // Noncacheable
